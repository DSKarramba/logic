// Generated by CoffeeScript 1.4.0
var And, DEBUG, Input, NULL, Node, Not, ONE, Or, Output, Wire, Z, clear, dark, draw_scheme, draw_text, state_from_value;

DEBUG = false;

ONE = {
  value: 1,
  text: "1",
  color: "#f5bb15"
};

NULL = {
  value: 0,
  text: "0",
  color: "#15bbf5"
};

Z = {
  value: -1,
  text: "Z",
  color: "#f515bb"
};

state_from_value = function(value) {
  var state;
  if (!value) {
    state = NULL;
  } else if (value > 0) {
    state = ONE;
  } else {
    state = Z;
  }
  return state;
};

dark = function(color) {
  switch (color) {
    case "#f5bb15":
      return "#b38400";
    case "#15bbf5":
      return "#0084b3";
    case "#f515bb":
      return "#b30084";
    default:
      return "#000";
  }
};

draw_text = function(ctx, x, y, text) {
  ctx.fillStyle = "#000";
  ctx.textAlign = 'left';
  return ctx.fillText(text, x, y);
};

clear = function(ctx) {
  return ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
};

Node = (function() {

  function Node(ctx, x, y) {
    this.ctx = ctx;
    this.x = x;
    this.y = y;
    this.visible = false;
    this.state = Z;
    this.connected = false;
    this.wires = [];
    this.element = false;
  }

  Node.prototype.add_wire = function(wire) {
    return this.wires.push(wire);
  };

  Node.prototype.get_wires = function() {
    return this.wires;
  };

  Node.prototype.draw = function() {
    if (this.visible) {
      this.ctx.strokeStyle = dark(this.state.color);
      this.ctx.fillStyle = this.state.color;
      this.ctx.lineWidth = 1;
      this.ctx.beginPath();
      this.ctx.arc(this.x, this.y, 4, 0, Math.PI * 2, true);
      this.ctx.closePath();
      this.ctx.fill();
      return this.ctx.stroke();
    }
  };

  return Node;

})();

Wire = (function() {

  function Wire(ctx, start_node, end_node) {
    this.ctx = ctx;
    this.start_node = start_node;
    this.end_node = end_node;
    this.start_node.add_wire(this);
    this.end_node.add_wire(this);
  }

  Wire.prototype.link = function() {
    this.end_node.state = this.start_node.state;
    return this.end_node.connected = true;
  };

  Wire.prototype.draw = function() {
    var height, width;
    this.ctx.strokeStyle = dark(this.end_node.state.color);
    this.ctx.lineWidth = 1;
    this.ctx.fillStyle = this.end_node.state.color;
    if ((this.start_node.x === this.end_node.x) || (this.start_node.y === this.end_node.y)) {
      this.ctx.beginPath();
      this.ctx.rect(this.start_node.x - 2, this.start_node.y - 2, this.end_node.x - this.start_node.x + 4, this.end_node.y - this.start_node.y + 4);
      this.ctx.closePath();
      this.ctx.fill();
      return this.ctx.stroke();
    } else {
      width = this.end_node.x - this.start_node.x;
      height = this.end_node.y - this.start_node.y;
      this.ctx.beginPath();
      this.ctx.rect(this.start_node.x - 2, this.start_node.y - 2, width / 2, 4);
      this.ctx.rect(this.start_node.x - 2 + width / 2, this.start_node.y + 2, 4, height / Math.abs(height) * (Math.abs(height) + 4));
      this.ctx.rect(this.start_node.x + 2 + width / 2, this.start_node.y - 2 + height, width / 2, 4);
      this.ctx.closePath();
      this.ctx.fill();
      return this.ctx.stroke();
    }
  };

  return Wire;

})();

Input = (function() {

  function Input(ctx, node) {
    this.ctx = ctx;
    this.node = node;
  }

  Input.prototype.sync = function() {
    this.node.state = this.state;
    return this.node.connected = true;
  };

  Input.prototype.set_state = function(state) {
    this.state = state;
    return this.sync();
  };

  Input.prototype.draw = function() {
    this.ctx.lineWidth = 1;
    this.ctx.strokeStyle = dark(this.node.state.color);
    this.ctx.fillStyle = this.node.state.color;
    this.ctx.beginPath();
    this.ctx.arc(this.node.x, this.node.y, 11, 0, Math.PI * 2, true);
    this.ctx.closePath();
    this.ctx.fill();
    this.ctx.stroke();
    this.ctx.fillStyle = '#000';
    this.ctx.textAlign = 'center';
    return this.ctx.fillText(this.state.text, this.node.x, this.node.y);
  };

  return Input;

})();

Output = (function() {

  function Output(ctx, node) {
    this.ctx = ctx;
    this.node = node;
  }

  Output.prototype.sync = function() {
    this.state = this.node.state;
    return this.node.connected = true;
  };

  Output.prototype.draw = function() {
    this.ctx.beginPath();
    this.ctx.arc(this.node.x, this.node.y, 11, 0, Math.PI * 2, true);
    this.ctx.closePath();
    this.ctx.fillStyle = this.node.state.color;
    this.ctx.fill();
    this.ctx.lineWidth = 1;
    this.ctx.strokeStyle = dark(this.node.state.color);
    this.ctx.stroke();
    this.ctx.fillStyle = '#000';
    this.ctx.textAlign = 'center';
    return this.ctx.fillText(this.state.text, this.node.x, this.node.y);
  };

  return Output;

})();

Not = (function() {

  function Not(ctx, _in, out) {
    this.ctx = ctx;
    this["in"] = _in;
    this.out = out;
    this.name = "Not";
    this["in"].element = this;
  }

  Not.prototype.sync = function() {
    switch (this["in"].state) {
      case ONE:
        this.out.state = NULL;
        break;
      case NULL:
        this.out.state = ONE;
        break;
      default:
        this.out.state = Z;
    }
    return this.out.connected = true;
  };

  Not.prototype.is_ready = function() {
    return this["in"].connected;
  };

  Not.prototype.draw = function() {
    this.ctx.beginPath();
    this.ctx.lineWidth = 2;
    this.ctx.strokeStyle = '#000';
    this.ctx.moveTo(this["in"].x, this["in"].y);
    this.ctx.lineTo(this["in"].x, this["in"].y - 23);
    this.ctx.lineTo(this["in"].x + 46, this["in"].y);
    this.ctx.lineTo(this["in"].x, this["in"].y + 23);
    this.ctx.lineTo(this["in"].x, this["in"].y);
    this.ctx.closePath();
    this.ctx.moveTo(this["in"].x + 60, this["in"].y);
    this.ctx.arc(this["in"].x + 53, this["in"].y, 7, 0, Math.PI * 2, true);
    this.ctx.stroke();
    this.ctx.beginPath();
    this.ctx.arc(this["in"].x + 53, this["in"].y, 6, 0, Math.PI * 2, true);
    this.ctx.closePath();
    this.ctx.fillStyle = this.out.state.color;
    this.ctx.fill();
    this["in"].visible = true;
    return this["in"].draw();
  };

  return Not;

})();

And = (function() {

  function And(ctx, in_0, in_1, out) {
    this.ctx = ctx;
    this.in_0 = in_0;
    this.in_1 = in_1;
    this.out = out;
    this.name = "And";
    this.in_0.element = this;
    this.in_1.element = this;
  }

  And.prototype.sync = function() {
    if ((this.in_0.state === Z) || (this.in_1.state === Z)) {
      this.out.state = NULL;
    } else {
      this.out.state = state_from_value(this.in_0.state.value * this.in_1.state.value);
    }
    return this.out.connected = true;
  };

  And.prototype.is_ready = function() {
    return this.in_0.connected && this.in_1.connected;
  };

  And.prototype.draw = function() {
    this.ctx.strokeStyle = '#000';
    this.ctx.lineWidth = 2;
    this.ctx.beginPath();
    this.ctx.moveTo(this.in_0.x, this.in_0.y);
    this.ctx.lineTo(this.in_0.x, this.in_0.y - 10);
    this.ctx.lineTo(this.in_0.x + 35, this.in_0.y - 10);
    this.ctx.bezierCurveTo(this.out.x + 8, this.out.y - 20, this.out.x + 8, this.out.y + 20, this.in_0.x + 35, this.in_1.y + 10);
    this.ctx.lineTo(this.in_0.x, this.in_1.y + 10);
    this.ctx.lineTo(this.in_0.x, this.in_0.y);
    this.ctx.closePath();
    this.ctx.stroke();
    this.in_0.visible = true;
    this.in_0.draw();
    this.in_1.visible = true;
    this.in_1.draw();
    this.out.visible = true;
    return this.out.draw();
  };

  return And;

})();

Or = (function() {

  function Or(ctx, in_0, in_1, out) {
    this.ctx = ctx;
    this.in_0 = in_0;
    this.in_1 = in_1;
    this.out = out;
    this.name = "Or";
    this.in_0.element = this;
    this.in_1.element = this;
  }

  Or.prototype.sync = function() {
    if ((this.in_0.state === Z) && (this.in_1.state === Z)) {
      this.out.state = Z;
    } else {
      this.out.state = state_from_value(Math.max(this.in_0.state.value, this.in_1.state.value));
    }
    return this.out.connected = true;
  };

  Or.prototype.is_ready = function() {
    return this.in_0.connected && this.in_1.connected;
  };

  Or.prototype.draw = function() {
    this.ctx.strokeStyle = '#000';
    this.ctx.lineWidth = 2;
    this.ctx.beginPath();
    this.ctx.moveTo(this.in_0.x - 10, this.in_0.y - 10);
    this.ctx.bezierCurveTo(this.in_0.x + 8, this.out.y - 20, this.in_0.x + 8, this.out.y + 20, this.in_0.x - 10, this.in_1.y + 10);
    this.ctx.bezierCurveTo(this.in_0.x + 30, this.in_1.y + 10, this.out.x - 15, this.out.y + 20, this.out.x, this.out.y);
    this.ctx.moveTo(this.in_0.x - 10, this.in_0.y - 10);
    this.ctx.bezierCurveTo(this.in_0.x + 30, this.in_0.y - 10, this.out.x - 15, this.out.y - 20, this.out.x, this.out.y);
    this.ctx.moveTo(this.in_0.x - 10, this.in_0.y - 10);
    this.ctx.closePath();
    this.ctx.stroke();
    this.in_0.visible = true;
    this.in_0.draw();
    this.in_1.visible = true;
    this.in_1.draw();
    this.out.visible = true;
    return this.out.draw();
  };

  return Or;

})();

draw_scheme = function(ctx) {
  var connected_nodes, elem, i, inp, input, logics, node, nodes, out, output, wire, wires, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _len5, _len6, _len7, _m, _n, _o, _p, _q, _ref, _ref1, _results;
  clear(ctx);
  ctx.font = '11pt PT Sans';
  ctx.textBaseline = 'middle';
  nodes = [new Node(ctx, 50, 40), new Node(ctx, 100, 40), new Node(ctx, 153, 40), new Node(ctx, 210, 40), new Node(ctx, 50, 85), new Node(ctx, 210, 70), new Node(ctx, 270, 55), new Node(ctx, 320, 55)];
  input = [new Input(ctx, nodes[0]), new Input(ctx, nodes[4])];
  wires = [new Wire(ctx, nodes[0], nodes[1]), new Wire(ctx, nodes[2], nodes[3]), new Wire(ctx, nodes[4], nodes[5]), new Wire(ctx, nodes[6], nodes[7])];
  logics = [new Not(ctx, nodes[1], nodes[2]), new And(ctx, nodes[3], nodes[5], nodes[6])];
  output = [new Output(ctx, nodes[7])];
  input[0].set_state(NULL);
  input[1].set_state(ONE);
  connected_nodes = [];
  for (_i = 0, _len = input.length; _i < _len; _i++) {
    inp = input[_i];
    connected_nodes.push(inp.node);
  }
  for (i = _j = 0, _ref = nodes.length - 1; 0 <= _ref ? _j <= _ref : _j >= _ref; i = 0 <= _ref ? ++_j : --_j) {
    node = connected_nodes[i];
    if (DEBUG) {
      console.log(i, connected_nodes);
    }
    if (node.element !== false) {
      if (DEBUG) {
        console.log(node.element.name, node.element.is_ready());
      }
      if (node.element.is_ready()) {
        node.element.sync();
        if (DEBUG) {
          console.log(node.element.out);
        }
        connected_nodes.push(node.element.out);
      }
    } else {
      _ref1 = node.get_wires();
      for (_k = 0, _len1 = _ref1.length; _k < _len1; _k++) {
        wire = _ref1[_k];
        if (!wire.end_node.connected) {
          wire.link();
          connected_nodes.push(wire.end_node);
        }
      }
    }
  }
  for (_l = 0, _len2 = output.length; _l < _len2; _l++) {
    out = output[_l];
    out.sync();
  }
  for (_m = 0, _len3 = wires.length; _m < _len3; _m++) {
    wire = wires[_m];
    wire.draw();
  }
  for (_n = 0, _len4 = input.length; _n < _len4; _n++) {
    elem = input[_n];
    elem.draw();
  }
  for (_o = 0, _len5 = logics.length; _o < _len5; _o++) {
    elem = logics[_o];
    elem.draw();
  }
  for (_p = 0, _len6 = output.length; _p < _len6; _p++) {
    elem = output[_p];
    elem.draw();
  }
  _results = [];
  for (_q = 0, _len7 = nodes.length; _q < _len7; _q++) {
    node = nodes[_q];
    _results.push(node.draw());
  }
  return _results;
};

draw_scheme(document.getElementById('examples').getContext('2d'));
